\documentclass[12pt,journal,compsoc]{IEEEtran}
\ifCLASSOPTIONcompsoc
\else
\fi
\ifCLASSINFOpdf
\else
\fi
\providecommand{\PSforPDF}[1]{#1}

\usepackage{listings}


\newcommand\MYhyperrefoptions{bookmarks=true,bookmarksnumbered=true,
pdfpagemode={UseOutlines},plainpages=false,pdfpagelabels=true,
colorlinks=true,linkcolor={black},citecolor={black},pagecolor={black},
urlcolor={black},
pdftitle={RSA Cryptosystem Generation of Public and Private Keys in Rust},
pdfsubject={Typesetting},%<!CHANGE!
pdfauthor={Pearson/Demorest},
pdfkeywords={RSA, rust, key generation, large prime numbers}}%<^!CHANGE!


\begin{document}
\lstset{language=bash}
%
% paper title
% can use linebreaks \\ within to get better formatting as desired
\title{RSA Cryptosystem Generation of Public and Private Keys in Rust}
\author{~Dr.~Elise~de Doncker,~Jason~Pearson,~Sam~Demorest% <-this % stops a space
\thanks{Dr. Elise de Doncker}}

% The paper headers
\markboth{}%
{Shell \MakeLowercase{\textit{et al.}}: RSA Cryptosystem Generation of Public and Private Keys in Rust}



\IEEEcompsoctitleabstractindextext{%
\begin{abstract}
	The goal of our project was to develop two programs. The first program would be for determining large prime numbers and the second program for using the first application to create public and private key pairs and using these pairs to encrypt/decrypt a message.
\end{abstract}
\begin{IEEEkeywords}
RSA, rust, key generation, large prime numbers
\end{IEEEkeywords}}


% make the title area
\maketitle

\IEEEdisplaynotcompsoctitleabstractindextext
\IEEEpeerreviewmaketitle



\section{Introduction}
\IEEEPARstart{T}{his} project under the supervision of Dr. Elise de Doncker is to implement the numerous algorithms needed to create a public and private RSA key pair set. 


\section{Research}
At the start of our project we first researched what an RSA key is and how to generate them and discovered it only takes a few steps. The first step is to create two prime numbers. The larger the prime number the better the encryption. Then with these two prime numbers we would be able to create a public and private key. 
\newline \indent We found two algorithms for finding if a number is prime or not. The first is the AKS Primality Test. This primality test is the best deterministic primality test known in terms of time complexity. This being said it is still very slow when compared to non deterministic primality testing algorithms. So we also looked at the Miller Rabin probabilistic primality tests to also test numbers which runs much faster than the AKS primality test.

\section{Design}
\indent While we were designing our project specifications we decided that two separate programs was a must. The idea behind this was if someone wanted to use any part of our program it would already be separated into its two major parts. An added benefit is that we can add our code to rust's cargo management website and allow easy access for either part of our program for any programmers. 
\newline
\indent Another decision was to select a programming language to use and we chose rust. The main reason for choosing rust is because it is low level and has great memory management built into the language, this would allow our program to go faster which is a must because the time complexity of algorithms is quite high.
\newline \indent


\section{Implementation}
The prime generator will use a two different primality tests. To generate relatively small (but still large) prime numbers, we will use the AKS Primality Test, which is the best performing deterministic primality test currently known. This is more to demonstrate an understanding of the principles behind the AKS test rather than to implement it for any serious purpose in our key generator. The AKS algorithm is still too slow for extremely large primes, so in the actual key generation process, we will use a series of Miller Rabin probabilistic primality tests to generate a number that can be determined to be prime within a probability threshold. We will be using various optimizations to the probability tests, such as not considering even numbers, in order to increase the speed at which we are able to determine whether or not a number is prime.  
\newline \indent The key generator will call the prime generation method of the first program and that will take care of all the work for prime number generation. After it gets the prime numbers p and q we use those to compute n which is simply p times q. Next we need to determine φ(n) which is simply $n - (p + q -1)$. After these are all computed we create a good e value and compute d. The e value is simply a number \\1 $<$ e $<φ(n)$. Then d = e$^{-1}$(mod(φ(n)), which is the private key part of the encryption.


\section{Testing}
Since the two programs were separate we had a pretty easy time testing each one out individually. 
For our prime number generator it was pretty easy to determine that our tests are working correctly. All that we had to do was send in some numbers that we know are prime and some that we are not prime and make sure that both tests respond accordingly. \\ \indent
To test our program we took an example and tested that our input and output matched. For the example we took some small prime numbers just for testing. So for p and q we took the values 61 and 53 respectively. Then we know that it should calculate for n as 3233 and we know that the totient that it creates should be 3120. For e we need to assign it a value so we can calculate the other values correctly. So for this example we chose 17 and when we calculate the d value we get 2753.  


\section{Result Analysis}

\section{Goals Reached}
Our initial goals were to create a primality testing section and to create public and private keys. We were successful in testing for prime numbers with a deterministic method and a non-deterministic method. Another goal of ours was to encrypt and decrypt an input string and we were also successful in this goal. \\ \indent One of our stretch goals was not reached. We were hoping to be able to use our program with other programs that use public and private key pairs such as ssh. We determined this to be out of scope because of the strict standards set up by the IEEE. 

\section{User Guide}
To run this program it is very simple. First you will need to build the program so cd to the directory and run 
\begin{lstlisting}[frame=single]
cargo build
\end{lstlisting} 
This compiles the program then to run it we simply do 
\begin{lstlisting}[frame=single]
cargo run X 
\end{lstlisting}
Where X is the bit size. The larger the bit size the longer the program will run. After you run the application it will ask for a string you would like encoded then decoded.

\section{Conclusion}


\appendices

\begin{thebibliography}{1}

\bibitem{IEEEhowto:kopka}
H.~Kopka and P.~W. Daly, \emph{A Guide to {\LaTeX}}, 3rd~ed.\hskip 1em plus
  0.5em minus 0.4em\relax Harlow, England: Addison-Wesley, 1999.

\end{thebibliography}

\end{document}


